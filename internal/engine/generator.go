package engine

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
)

// RealGenerator is a real implementation of the Generator interface
type RealGenerator struct {
	logger *slog.Logger
}

// NewRealGenerator creates a new RealGenerator
func NewRealGenerator(logger *slog.Logger) *RealGenerator {
	if logger == nil {
		logger = slog.New(slog.NewTextHandler(os.Stdout, nil))
	}
	return &RealGenerator{
		logger: logger,
	}
}

// Generate generates adapter code for the given package plan
func (r *RealGenerator) Generate(plan *PackagePlan) error {
	r.logger.Info("Generating adapter code", 
		"package", plan.Name, 
		"importPath", plan.ImportPath,
		"sourceFiles", plan.SourceFiles)
	
	if len(plan.SourceFiles) == 0 {
		return fmt.Errorf("no source files to generate from")
	}

	// Use the first source file
	sourceFile := plan.SourceFiles[0]
	ext := filepath.Ext(sourceFile)
	baseName := strings.TrimSuffix(filepath.Base(sourceFile), ext)
	outputFile := filepath.Join(filepath.Dir(sourceFile), baseName+"_adp"+ext)

	r.logger.Info("Creating adapter file", "path", outputFile)

	// Create output file
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	// Parse source file
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, sourceFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse source file: %w", err)
	}

	// Get package name
	pkgName := file.Name.Name
	if plan.Config != nil && plan.Config.PackageName != "" {
		pkgName = plan.Config.PackageName
	}

	// Get import path and alias
	importPath := ""
	importAlias := ""
	if len(plan.Config.Packages) > 0 {
		pkg := plan.Config.Packages[0]
		importPath = pkg.ImportPath
		if pkg.ImportAlias != "" {
			importAlias = pkg.ImportAlias
		} else {
			parts := strings.Split(pkg.ImportPath, "/")
			importAlias = parts[len(parts)-1]
		}
	}

	r.logger.Info("Writing adapter to file", "path", outputFile)

	// Create a buffer to build the output
	var buf bytes.Buffer

	// Write the header
	buf.WriteString(fmt.Sprintf(`// Code generated by adptool. DO NOT EDIT.
// source: %s

package %s

`, filepath.Base(sourceFile), pkgName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", importAlias, importPath))

	// Add other imports
	for _, imp := range file.Imports {
		if imp.Path.Value == fmt.Sprintf(`"%s"`, importPath) {
			continue // Skip duplicate import
		}
		if imp.Name != nil {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", imp.Name.Name, imp.Path.Value))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s\n", imp.Path.Value))
		}
	}
	buf.WriteString(")\n\n")

	// Process declarations
	for _, decl := range file.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range d.Specs {
				switch s := spec.(type) {
				case *ast.ValueSpec:
					// Handle constants and variables
					for _, name := range s.Names {
						if name.IsExported() {
							exportedName := name.Name
							if d.Tok == token.CONST {
								exportedName = r.applyRenamingRules(plan, exportedName, "const")
							} else if d.Tok == token.VAR {
								exportedName = r.applyRenamingRules(plan, exportedName, "var")
							}
							buf.WriteString(fmt.Sprintf("// %s is an adapter for %s.%s\n", 
								exportedName, importAlias, name.Name))
							buf.WriteString(fmt.Sprintf("var %s = %s.%s\n\n", 
								exportedName, importAlias, name.Name))
						}
					}

				case *ast.TypeSpec:
					if s.Name.IsExported() {
						typeName := s.Name.Name
						newTypeName := r.applyRenamingRules(plan, typeName, "type")
						
						// Write type documentation
						buf.WriteString(fmt.Sprintf("// %s is an adapter for %s.%s\n", 
							newTypeName, importAlias, typeName))
						
						// Write type definition
						buf.WriteString(fmt.Sprintf("type %s = %s.%s\n\n", 
							newTypeName, importAlias, typeName))
					}
				}
			}

		case *ast.FuncDecl:
			if d.Name.IsExported() {
				funcName := d.Name.Name
				newFuncName := r.applyRenamingRules(plan, funcName, "func")

				// Handle methods (functions with receivers)
				if d.Recv != nil && len(d.Recv.List) > 0 {
					recv := d.Recv.List[0]
					recvType := r.typeString(recv.Type, importAlias)
					recvName := "r"
					if len(recv.Names) > 0 {
						recvName = recv.Names[0].Name
					}

					// Write method documentation
					buf.WriteString(fmt.Sprintf("// %s is an adapter method for %s.%s\n", 
						newFuncName, importAlias, funcName))

					// Write method signature
					buf.WriteString(fmt.Sprintf("func (%s %s) %s", 
						recvName, recvType, r.funcSignature(d, newFuncName, importAlias)))
				} else {
					// Write function documentation
					buf.WriteString(fmt.Sprintf("// %s is an adapter for %s.%s\n", 
						newFuncName, importAlias, funcName))

					// Write function signature
					buf.WriteString(fmt.Sprintf("func %s", 
						r.funcSignature(d, newFuncName, importAlias)))
				}
			}
		}
	}

	// Write the generated code to the output file
	if _, err := f.Write(buf.Bytes()); err != nil {
		return fmt.Errorf("failed to write to output file: %w", err)
	}

	r.logger.Info("Successfully generated adapter file", "path", outputFile)
	return nil
}


// applyRenamingRules applies renaming rules based on the configuration
func (r *RealGenerator) applyRenamingRules(plan *PackagePlan, name, kind string) string {
	// For now, just return the original name to get it to compile.
	// The actual rule application logic will be implemented later using CompiledRuleSet.
	return name
}

// typeString converts an AST type expression to a string
func (r *RealGenerator) typeString(expr ast.Expr, importAlias string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", t.X, t.Sel.Name)
	case *ast.StarExpr:
		return "*" + r.typeString(t.X, importAlias)
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + r.typeString(t.Elt, importAlias)
		}
		return fmt.Sprintf("[%s]%s", t.Len, r.typeString(t.Elt, importAlias))
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", 
			r.typeString(t.Key, importAlias),
			r.typeString(t.Value, importAlias))
	case *ast.FuncType:
		return "func" + r.funcTypeString(t, "", importAlias)
	case *ast.StructType:
		return "struct{...}" // Simplified for now
	case *ast.InterfaceType:
		return "interface{...}" // Simplified for now
	default:
		return fmt.Sprintf("%T", expr)
	}
}

// funcTypeString converts a function type to a string
func (r *RealGenerator) funcTypeString(ft *ast.FuncType, name, importAlias string) string {
	var params, results []string

	if ft.Params != nil {
		for _, f := range ft.Params.List {
			typeStr := r.typeString(f.Type, importAlias)
			if len(f.Names) == 0 {
				params = append(params, typeStr)
			} else {
				for range f.Names {
					params = append(params, typeStr)
				}
			}
		}
	}

	if ft.Results != nil {
		for _, f := range ft.Results.List {
			typeStr := r.typeString(f.Type, importAlias)
			if len(f.Names) == 0 {
				results = append(results, typeStr)
			} else {
				for _, name := range f.Names {
					results = append(results, fmt.Sprintf("%s %s", name.Name, typeStr))
				}
			}
		}
	}

	signature := name + "(" + strings.Join(params, ", ") + ")"
	if len(results) > 0 {
		if len(results) == 1 && !strings.Contains(results[0], " ") {
			signature += " " + results[0]
		} else {
			signature += " (" + strings.Join(results, ", ") + ")"
		}
	}

	return signature
}
func (r *RealGenerator) funcSignature(fn *ast.FuncDecl, name, importAlias string) string {
	var params, results []string

	// Process type parameters if they exist
	if fn.Type.TypeParams != nil {
		var typeParams []string
		for _, param := range fn.Type.TypeParams.List {
			for _, name := range param.Names {
				typeParams = append(typeParams, name.Name)
			}
		}
	}

	// Process parameters
	if fn.Type.Params != nil {
		for _, param := range fn.Type.Params.List {
			typeStr := r.typeString(param.Type, importAlias)
			if len(param.Names) > 0 {
				for _, name := range param.Names {
					params = append(params, fmt.Sprintf("%s %s", name.Name, typeStr))
				}
			} else {
				params = append(params, typeStr)
			}
		}
	}

	// Process results
	if fn.Type.Results != nil {
		for _, result := range fn.Type.Results.List {
			typeStr := r.typeString(result.Type, importAlias)
			if len(result.Names) > 0 {
				for _, name := range result.Names {
					results = append(results, fmt.Sprintf("%s %s", name.Name, typeStr))
				}
			} else {
				results = append(results, typeStr)
			}
		}
	}

	// Build the function signature
	signature := name

	// Add type parameters if they exist
	if fn.Type.TypeParams != nil {
		signature += "["
		for i, param := range fn.Type.TypeParams.List {
			if i > 0 {
				signature += ", "
			}
			signature += r.typeString(param.Type, importAlias)
		}
		signature += "]"
	}

	// Add parameters
	signature += "(" + strings.Join(params, ", ") + ")"

	// Add return types
	if len(results) > 0 {
		signature += " "
		if len(results) > 1 || results[0] != "" {
			signature += "(" + strings.Join(results, ", ") + ")"
		} else {
			signature += results[0]
		}
	}

	// Add function body
	signature += " {\n"

	// Generate parameter names for the function call
	var paramNames []string
	if fn.Type.Params != nil {
		for _, param := range fn.Type.Params.List {
			if len(param.Names) > 0 {
				for _, name := range param.Names {
					paramNames = append(paramNames, name.Name)
				}
			} else {
				paramNames = append(paramNames, "_") // Use _ for unnamed parameters
			}
		}
	}

	// Generate the function call
	if fn.Recv != nil {
		// Method call
		recvName := "r"
		if len(fn.Recv.List[0].Names) > 0 {
			recvName = fn.Recv.List[0].Names[0].Name
		}
		signature += fmt.Sprintf("\treturn %s.%s(%s)", recvName, fn.Name.Name, strings.Join(paramNames, ", "))
	} else {
		// Function call
		signature += fmt.Sprintf("\treturn %s.%s(%s)", importAlias, fn.Name.Name, strings.Join(paramNames, ", "))
	}

	signature += "\n}"

	return signature
}

func getParamNames(fl *ast.FieldList) []string {
	if fl == nil {
		return []string{}
	}
	var names []string
	for _, f := range fl.List {
		for _, name := range f.Names {
			names = append(names, name.Name)
		}
		// For unnamed parameters, use a placeholder
		if len(f.Names) == 0 {
			names = append(names, "_") // Use _ for unnamed parameters
		}
	}
	return names
}

// processFieldList processes a field list for functions and methods
func processFieldList(fl *ast.FieldList) string {
	if fl == nil {
		return ""
	}
	var fields []string
	for _, f := range fl.List {
		var names []string
		for _, n := range f.Names {
			names = append(names, n.Name)
		}
		typeStr := types.ExprString(f.Type)
		if len(names) > 0 {
			fields = append(fields, fmt.Sprintf("%s %s", strings.Join(names, ", "), typeStr))
		} else {
			fields = append(fields, typeStr)
		}
	}
	return strings.Join(fields, ", ")
}

// processImports processes the imports for the adapter
func (r *RealGenerator) processImports(buf *bytes.Buffer, imports []*ast.ImportSpec, importPath, importAlias string) {
	buf.WriteString("import (\n")
	// Add the source package import with alias
	buf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", importAlias, importPath))

	// Add other imports from the source file
	for _, imp := range imports {
		// Skip the source package import to avoid duplicate
		if imp.Path.Value == fmt.Sprintf(`\"%s\"`, importPath) {
			continue
		}
		
		if imp.Name != nil {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", imp.Name.Name, imp.Path.Value))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s\n", imp.Path.Value))
		}
	}
	buf.WriteString(")\n\n")
}

// processDeclarations processes all declarations in the source file
func (r *RealGenerator) processDeclarations(file *ast.File, plan *PackagePlan, importAlias string) ([]string, []string, []string, []string, []string) {
	var (
		consts  []string
		vars    []string
		types   []string
		funcs   []string
		methods []string
	)

	// Process all declarations in the file
	for _, decl := range file.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range d.Specs {
				switch s := spec.(type) {
				case *ast.ValueSpec:
					for _, name := range s.Names {
						if name.IsExported() {
							switch d.Tok {
							case token.CONST:
								consts = append(consts, name.Name)
							case token.VAR:
								vars = append(vars, name.Name)
							}
						}
					}
				case *ast.TypeSpec:
					if s.Name.IsExported() {
						types = append(types, s.Name.Name)
					}
				}
			}
		case *ast.FuncDecl:
			if d.Name.IsExported() {
				if d.Recv != nil {
						methods = append(methods, d.Name.Name)
					} else {
						funcs = append(funcs, d.Name.Name)
					}
				}
		}
	}

	return consts, vars, types, funcs, methods
}
