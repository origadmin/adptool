package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"text/template"
	"time"

	"github.com/origadmin/adptool/internal/util"
)

// DefaultHeaderTemplate is the built-in template for the generated file header.
// It includes the standard "Code generated by ... DO NOT EDIT." line recognized by Go tools.
const DefaultHeaderTemplate = `{{if .CopyrightHolder}}// Copyright {{.Year}} {{.CopyrightHolder}}. All rights reserved.
//
{{end}}// Code generated by adptool. DO NOT EDIT.
//
// This file is generated from {{.SourceFile}}.
`

// Builder is responsible for building the output file from collected declarations.
type Builder struct {
	fset            *token.FileSet
	outputFilePath  string
	aliasFile       *ast.File
	formatCode      bool
	header          string // Final, rendered header content
	headerTemplate  string // Header template string
	copyrightHolder string
	writer          io.Writer
}

// NewBuilder creates a new Builder.
func NewBuilder(packageName string, outputFilePath string, copyrightHolder string) *Builder {
	return &Builder{
		fset:           token.NewFileSet(),
		outputFilePath: outputFilePath,
		aliasFile: &ast.File{
			Name:  ast.NewIdent(packageName),
			Decls: []ast.Decl{},
		},
		formatCode:      true,
		headerTemplate:  DefaultHeaderTemplate, // Use the built-in default template
		copyrightHolder: copyrightHolder,
	}
}

// WithFormatCode sets whether to automatically format after generating code
func (b *Builder) WithFormatCode(format bool) *Builder {
	b.formatCode = format
	return b
}

// WithHeaderTemplate sets a custom header template.
func (b *Builder) WithHeaderTemplate(headerTemplate string) *Builder {
	if headerTemplate != "" {
		b.headerTemplate = headerTemplate
	}
	return b
}

// RenderHeader executes the header template with the given source file name.
func (b *Builder) RenderHeader(sourceFile string) error {
	tmpl, err := template.New("header").Parse(b.headerTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse header template: %w", err)
	}

	data := struct {
		Year            int
		SourceFile      string
		CopyrightHolder string
	}{
		Year:            time.Now().Year(),
		SourceFile:      sourceFile,
		CopyrightHolder: b.copyrightHolder,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute header template: %w", err)
	}

	b.header = buf.String()
	return nil
}

// Build builds the output file structure from the collected data.
// It now accepts pathToAlias to correctly resolve package aliases.
func (b *Builder) Build(importSpecs map[string]*ast.ImportSpec, allPackageDecls map[string]*packageDecls, definedTypes map[string]bool, pathToAlias map[string]string) {
	var orderedDecls []ast.Decl

	// Set package comment on the AST file
	if b.aliasFile.Name != nil {
		commentText := fmt.Sprintf("// Package %s contains generated code by adptool.", b.aliasFile.Name.Name)
		b.aliasFile.Doc = &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: commentText},
			},
		}
	}

	importDecl := b.buildImportDeclaration(importSpecs)
	if len(importDecl.(*ast.GenDecl).Specs) > 0 {
		orderedDecls = append(orderedDecls, importDecl)
	}

	allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls := b.collectAllDeclarations(allPackageDecls, definedTypes, pathToAlias)

	if len(allConstSpecs) > 0 {
		constDecl := &ast.GenDecl{
			Tok:    token.CONST,
			Lparen: token.Pos(1), // Use Lparen to indicate a grouped declaration
			Specs:  allConstSpecs,
		}
		orderedDecls = append(orderedDecls, constDecl)
	}

	if len(allVarSpecs) > 0 {
		varDecl := &ast.GenDecl{
			Tok:    token.VAR,
			Lparen: token.Pos(1), // Use Lparen to indicate a grouped declaration
			Specs:  allVarSpecs,
		}
		orderedDecls = append(orderedDecls, varDecl)
	}

	if len(allTypeSpecs) > 0 {
		typeDecl := &ast.GenDecl{
			Tok:    token.TYPE,
			Lparen: token.Pos(1), // Use Lparen to indicate a grouped declaration
			Specs:  allTypeSpecs,
		}
		orderedDecls = append(orderedDecls, typeDecl)
	}

	orderedDecls = append(orderedDecls, allFuncDecls...)

	b.aliasFile.Decls = orderedDecls
}

// Write writes the generated code to the output file or to the configured writer.
func (b *Builder) Write() error {
	// If a writer is configured, write to it and bypass file operations.
	if b.writer != nil {
		return b.writeToWriter(b.writer)
	}

	// Original file writing logic
	return b.writeToFile()
}

func (b *Builder) writeToWriter(w io.Writer) error {
	// Write the rendered header.
	if b.header != "" {
		if _, err := w.Write([]byte(b.header)); err != nil {
			return fmt.Errorf("failed to write header to writer: %w", err)
		}
		if _, err := w.Write([]byte("\n")); err != nil {
			return err
		}
	}

	// Manually write the package comment.
	if b.aliasFile.Doc != nil {
		for _, comment := range b.aliasFile.Doc.List {
			if _, err := w.Write([]byte(comment.Text + "\n")); err != nil {
				return fmt.Errorf("failed to write package comment: %w", err)
			}
		}
	}

	// Manually write the package declaration.
	if _, err := fmt.Fprintf(w, "package %s\n\n", b.aliasFile.Name.Name); err != nil {
		return fmt.Errorf("failed to write package declaration: %w", err)
	}

	// Print the declarations one by one.
	for _, decl := range b.aliasFile.Decls {
		if err := printer.Fprint(w, b.fset, decl); err != nil {
			return fmt.Errorf("failed to print declaration: %w", err)
		}
		if _, err := w.Write([]byte("\n\n")); err != nil {
			return err
		}
	}

	return nil
}

func (b *Builder) writeToFile() error {
	outputDir := filepath.Dir(b.outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create a temporary file first to avoid partial writes
	tempFile, err := os.CreateTemp(outputDir, "temp-*.go")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	defer func() {
		tempFile.Close()
		if err != nil {
			os.Remove(tempFile.Name())
		}
	}()

	// Use the same writing logic as writeToWriter
	if err := b.writeToWriter(tempFile); err != nil {
		return err
	}

	// Close the temp file before renaming
	if err := tempFile.Close(); err != nil {
		return fmt.Errorf("failed to close temporary file: %w", err)
	}

	// Atomically replace the target file
	if err := os.Rename(tempFile.Name(), b.outputFilePath); err != nil {
		return fmt.Errorf("failed to rename temporary file: %w", err)
	}

	// According to formatCode option, decide whether to run goimports
	if b.formatCode {
		if err := util.RunGoImports(b.outputFilePath); err != nil {
			return fmt.Errorf("failed to format generated code with goimports: %w", err)
		}
	}

	return nil
}

func (b *Builder) buildImportDeclaration(importSpecs map[string]*ast.ImportSpec) ast.Decl {
	// First, collect and sort the import paths to ensure deterministic order
	importPaths := make([]string, 0, len(importSpecs))
	for path := range importSpecs {
		importPaths = append(importPaths, path)
	}
	sort.Strings(importPaths)

	// Then collect the import specs in the sorted order
	finalImportSpecs := make([]ast.Spec, 0, len(importSpecs))
	for _, path := range importPaths {
		if spec, exists := importSpecs[path]; exists {
			finalImportSpecs = append(finalImportSpecs, spec)
		}
	}

	// Sort the imports by path to maintain consistent ordering
	sort.Slice(finalImportSpecs, func(i, j int) bool {
		var iPath, jPath string
		if imp, ok := finalImportSpecs[i].(*ast.ImportSpec); ok && imp.Path != nil {
			iPath = imp.Path.Value
		}
		if imp, ok := finalImportSpecs[j].(*ast.ImportSpec); ok && imp.Path != nil {
			jPath = imp.Path.Value
		}
		return iPath < jPath
	})

	return &ast.GenDecl{Tok: token.IMPORT, Specs: finalImportSpecs}
}

// pendingSymbol holds information about a symbol that needs to be generated.
// It's used to create a deterministic processing order for name generation.
type pendingSymbol struct {
	originalName       string
	originalImportPath string
	// A pointer to the original identifier in the AST.
	// This provides a unique identity for each symbol.
	ident *ast.Ident
}

// collectAllDeclarations generates declarations in a fully deterministic way.
func (b *Builder) collectAllDeclarations(allPackageDecls map[string]*packageDecls, definedTypes map[string]bool, pathToAlias map[string]string) ([]ast.Spec, []ast.Spec, []ast.Spec, []ast.Decl) {
	var symbols []pendingSymbol

	// Sort package import paths to ensure a deterministic starting point
	var sortedImportPaths []string
	for importPath := range allPackageDecls {
		sortedImportPaths = append(sortedImportPaths, importPath)
	}
	sort.Strings(sortedImportPaths)

	// Pass 1, Step A: Collect all symbols
	for _, importPath := range sortedImportPaths {
		pkgDecls := allPackageDecls[importPath]

		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							symbols = append(symbols, pendingSymbol{originalName: name.Name, originalImportPath: importPath, ident: name})
						}
					}
				}
			}
		}
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							symbols = append(symbols, pendingSymbol{originalName: name.Name, originalImportPath: importPath, ident: name})
						}
					}
				}
			}
		}
		for _, spec := range pkgDecls.typeSpecs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				symbols = append(symbols, pendingSymbol{originalName: typeSpec.Name.Name, originalImportPath: importPath, ident: typeSpec.Name})
			}
		}
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				symbols = append(symbols, pendingSymbol{originalName: funcDecl.Name.Name, originalImportPath: importPath, ident: funcDecl.Name})
			}
		}
	}

	// Pass 1, Step B: Sort symbols for deterministic processing (by name, then by import path).
	sort.Slice(symbols, func(i, j int) bool {
		if symbols[i].originalName != symbols[j].originalName {
			return symbols[i].originalName < symbols[j].originalName
		}
		return symbols[i].originalImportPath < symbols[j].originalImportPath
	})

	// Pass 1, Step C: Generate unique names using the grouping strategy.
	nameMap := make(map[*ast.Ident]string)
	usedNames := make(map[string]bool)
	for name := range definedTypes {
		usedNames[name] = true
	}

	// Group symbols by their original name.
	groupedSymbols := make(map[string][]*pendingSymbol)
	for i := range symbols {
		s := &symbols[i]
		groupedSymbols[s.originalName] = append(groupedSymbols[s.originalName], s)
	}

	// To ensure deterministic processing of groups, get and sort the group keys.
	var sortedOriginalNames []string
	for name := range groupedSymbols {
		sortedOriginalNames = append(sortedOriginalNames, name)
	}
	sort.Strings(sortedOriginalNames)

	// Process each group to assign final, unique names.
	for _, originalName := range sortedOriginalNames {
		group := groupedSymbols[originalName]

		// The symbols within the group are already sorted by import path.
		for i, symbol := range group {
			var finalName string
			// The first symbol in a group (i=0) tries to get the clean, unsuffixed name.
			// Subsequent symbols (i>0) get a numeric suffix.
			if i == 0 {
				finalName = originalName
			} else {
				finalName = originalName + strconv.Itoa(i)
			}

			// If the desired name is already taken (by a defined type or a symbol from another group),
			// find the next available numeric suffix.
			if usedNames[finalName] {
				nextSuffix := i + 1
				if i == 0 {
					// If the base name itself was taken, start searching from suffix 1.
					nextSuffix = 1
				}
				for {
					newName := originalName + strconv.Itoa(nextSuffix)
					if !usedNames[newName] {
						finalName = newName
						break
					}
					nextSuffix++
				}
			}

			usedNames[finalName] = true
			nameMap[symbol.ident] = finalName
		}
	}

	// Pass 2: Build new declarations using the deterministic name map
	var allConstSpecs, allVarSpecs, allTypeSpecs []ast.Spec
	var allFuncDecls []ast.Decl
	processedSpecs := make(map[ast.Spec]bool)

	// This approach is simpler and correct: iterate through the sorted symbols and create the final lists.
	for _, s := range symbols {
		newName := nameMap[s.ident]
		found := false

		// This is inefficient, but guarantees order. A better way would be to map ident back to its original decl.
		// For now, let's find which declaration this symbol belongs to.
		pkgDecls := allPackageDecls[s.originalImportPath]

		// Find in consts
		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							if name == s.ident {
								if !processedSpecs[spec] {
									newSpec := *valSpec
									newSpec.Names = []*ast.Ident{ast.NewIdent(newName)}
									allConstSpecs = append(allConstSpecs, &newSpec)
									processedSpecs[spec] = true
								}
								found = true
								break
							}
						}
					}
					if found {
						break
					}
				}
			}
			if found {
				break
			}
		}
		if found {
			continue
		}

		// Find in vars
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							if name == s.ident {
								if !processedSpecs[spec] {
									newSpec := *valSpec
									newSpec.Names = []*ast.Ident{ast.NewIdent(newName)}
									allVarSpecs = append(allVarSpecs, &newSpec)
									processedSpecs[spec] = true
								}
								found = true
								break
							}
						}
					}
					if found {
						break
					}
				}
			}
			if found {
				break
			}
		}
		if found {
			continue
		}

		// Find in types
		for _, spec := range pkgDecls.typeSpecs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				if typeSpec.Name == s.ident {
					if !processedSpecs[spec] {
						newSpec := *typeSpec
						newSpec.Name = ast.NewIdent(newName)
						allTypeSpecs = append(allTypeSpecs, &newSpec)
						processedSpecs[spec] = true
					}
					found = true
					break
				}
			}
		}
		if found {
			continue
		}

		// Find in funcs
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				if funcDecl.Name == s.ident {
					newDecl := *funcDecl
					newDecl.Name = ast.NewIdent(newName)
					allFuncDecls = append(allFuncDecls, &newDecl)
					found = true
					break
				}
			}
		}
	}

	return allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls
}
