package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"text/template"
	"time"

	"github.com/origadmin/adptool/internal/util"
)

// DefaultHeaderTemplate is the built-in template for the generated file header.
// It includes the standard "Code generated by ... DO NOT EDIT." line recognized by Go tools.
const DefaultHeaderTemplate = `{{if .CopyrightHolder}}// Copyright {{.Year}} {{.CopyrightHolder}}. All rights reserved.
//
{{end}}// Code generated by adptool. DO NOT EDIT.
//
// This file is generated from {{.SourceFile}}.
`

// Builder is responsible for building the output file from collected declarations.
type Builder struct {
	fset            *token.FileSet
	outputFilePath  string
	aliasFile       *ast.File
	formatCode      bool
	header          string // Final, rendered header content
	headerTemplate  string // Header template string
	copyrightHolder string
	writer          io.Writer
}

// NewBuilder creates a new Builder.
func NewBuilder(packageName string, outputFilePath string, copyrightHolder string) *Builder {
	return &Builder{
		fset:           token.NewFileSet(),
		outputFilePath: outputFilePath,
		aliasFile: &ast.File{
			Name:  ast.NewIdent(packageName),
			Decls: []ast.Decl{},
		},
		formatCode:      true,
		headerTemplate:  DefaultHeaderTemplate, // Use the built-in default template
		copyrightHolder: copyrightHolder,
	}
}

// WithFormatCode sets whether to automatically format after generating code
func (b *Builder) WithFormatCode(format bool) *Builder {
	b.formatCode = format
	return b
}

// WithHeaderTemplate sets a custom header template.
func (b *Builder) WithHeaderTemplate(headerTemplate string) *Builder {
	if headerTemplate != "" {
		b.headerTemplate = headerTemplate
	}
	return b
}

// RenderHeader executes the header template with the given source file name.
func (b *Builder) RenderHeader(sourceFile string) error {
	tmpl, err := template.New("header").Parse(b.headerTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse header template: %w", err)
	}

	data := struct {
		Year            int
		SourceFile      string
		CopyrightHolder string
	}{
		Year:            time.Now().Year(),
		SourceFile:      sourceFile,
		CopyrightHolder: b.copyrightHolder,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute header template: %w", err)
	}

	b.header = buf.String()
	return nil
}

// sortedSpec is a helper struct to sort specs by import path and then by name.
type sortedSpec struct {
	spec       ast.Spec
	importPath string
	name       string
}

// sortedDecl is a helper struct to sort decls by import path and then by name.
type sortedDecl struct {
	decl       ast.Decl
	importPath string
	name       string
}

// Build builds the output file structure from the collected data.
func (b *Builder) Build(importSpecs map[string]*ast.ImportSpec, allPackageDecls map[string]*packageDecls, definedTypes map[string]bool, pathToAlias map[string]string) {
	var orderedDecls []ast.Decl

	// Set package comment on the AST file
	if b.aliasFile.Name != nil {
		commentText := fmt.Sprintf("// Package %s contains generated code by adptool.", b.aliasFile.Name.Name)
		b.aliasFile.Doc = &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: commentText},
			},
		}
	}

	importDecl := b.buildImportDeclaration(importSpecs)
	if len(importDecl.(*ast.GenDecl).Specs) > 0 {
		orderedDecls = append(orderedDecls, importDecl)
	}

	// Generate the map of original identifiers to their new, unique names.
	nameMap := b.collectAndResolveNames(allPackageDecls, definedTypes)

	// Create intermediate lists to hold declarations with their metadata for sorting.
	var constsToSort []sortedSpec
	var varsToSort []sortedSpec
	var typesToSort []sortedSpec
	var funcsToSort []sortedDecl

	// Iterate through all packages to populate the intermediate lists.
	for importPath, pkgDecls := range allPackageDecls {
		// Populate consts
		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							newName := nameMap[name]
							newSpec := *valSpec // copy
							newSpec.Names = []*ast.Ident{ast.NewIdent(newName)}
							constsToSort = append(constsToSort, sortedSpec{spec: &newSpec, importPath: importPath, name: newName})
						}
					}
				}
			}
		}
		// Populate vars
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							newName := nameMap[name]
							newSpec := *valSpec // copy
							newSpec.Names = []*ast.Ident{ast.NewIdent(newName)}
							varsToSort = append(varsToSort, sortedSpec{spec: &newSpec, importPath: importPath, name: newName})
						}
					}
				}
			}
		}
		// Populate types
		for _, spec := range pkgDecls.typeSpecs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				newName := nameMap[typeSpec.Name]
				newSpec := *typeSpec // copy
				newSpec.Name = ast.NewIdent(newName)
				typesToSort = append(typesToSort, sortedSpec{spec: &newSpec, importPath: importPath, name: newName})
			}
		}
		// Populate funcs
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				newName := nameMap[funcDecl.Name]
				newDecl := *funcDecl // copy
				newDecl.Name = ast.NewIdent(newName)
				funcsToSort = append(funcsToSort, sortedDecl{decl: &newDecl, importPath: importPath, name: newName})
			}
		}
	}

	// Sort each list by import path, then by name.
	sort.Slice(constsToSort, func(i, j int) bool {
		if constsToSort[i].importPath != constsToSort[j].importPath {
			return constsToSort[i].importPath < constsToSort[j].importPath
		}
		return constsToSort[i].name < constsToSort[j].name
	})
	sort.Slice(varsToSort, func(i, j int) bool {
		if varsToSort[i].importPath != varsToSort[j].importPath {
			return varsToSort[i].importPath < varsToSort[j].importPath
		}
		return varsToSort[i].name < varsToSort[j].name
	})
	sort.Slice(typesToSort, func(i, j int) bool {
		if typesToSort[i].importPath != typesToSort[j].importPath {
			return typesToSort[i].importPath < typesToSort[j].importPath
		}
		return typesToSort[i].name < typesToSort[j].name
	})
	sort.Slice(funcsToSort, func(i, j int) bool {
		if funcsToSort[i].importPath != funcsToSort[j].importPath {
			return funcsToSort[i].importPath < funcsToSort[j].importPath
		}
		return funcsToSort[i].name < funcsToSort[j].name
	})

	// Extract the sorted specs and decls into the final lists.
	var allConstSpecs []ast.Spec
	for _, s := range constsToSort {
		allConstSpecs = append(allConstSpecs, s.spec)
	}
	var allVarSpecs []ast.Spec
	for _, s := range varsToSort {
		allVarSpecs = append(allVarSpecs, s.spec)
	}
	var allTypeSpecs []ast.Spec
	for _, s := range typesToSort {
		allTypeSpecs = append(allTypeSpecs, s.spec)
	}
	var allFuncDecls []ast.Decl
	for _, s := range funcsToSort {
		allFuncDecls = append(allFuncDecls, s.decl)
	}

	// Build the final orderedDecls list.
	if len(allConstSpecs) > 0 {
		orderedDecls = append(orderedDecls, &ast.GenDecl{Tok: token.CONST, Specs: allConstSpecs})
	}
	if len(allVarSpecs) > 0 {
		orderedDecls = append(orderedDecls, &ast.GenDecl{Tok: token.VAR, Specs: allVarSpecs})
	}
	if len(allTypeSpecs) > 0 {
		orderedDecls = append(orderedDecls, &ast.GenDecl{Tok: token.TYPE, Specs: allTypeSpecs})
	}
	orderedDecls = append(orderedDecls, allFuncDecls...)

	b.aliasFile.Decls = orderedDecls
}

// Write writes the generated code to the output file or to the configured writer.
func (b *Builder) Write() error {
	// If a writer is configured, write to it and bypass file operations.
	if b.writer != nil {
		return b.writeToWriter(b.writer)
	}

	// Original file writing logic
	return b.writeToFile()
}

func (b *Builder) writeToWriter(w io.Writer) error {
	// Write the rendered header.
	if b.header != "" {
		if _, err := w.Write([]byte(b.header)); err != nil {
			return fmt.Errorf("failed to write header to writer: %w", err)
		}
		if _, err := w.Write([]byte("\n")); err != nil {
			return err
		}
	}

	// Manually write the package comment.
	if b.aliasFile.Doc != nil {
		for _, comment := range b.aliasFile.Doc.List {
			if _, err := w.Write([]byte(comment.Text + "\n")); err != nil {
				return fmt.Errorf("failed to write package comment: %w", err)
			}
		}
	}

	// Manually write the package declaration.
	if _, err := fmt.Fprintf(w, "package %s\n\n", b.aliasFile.Name.Name); err != nil {
		return fmt.Errorf("failed to write package declaration: %w", err)
	}

	// Print the declarations one by one.
	for _, decl := range b.aliasFile.Decls {
		if err := printer.Fprint(w, b.fset, decl); err != nil {
			return fmt.Errorf("failed to print declaration: %w", err)
		}
		if _, err := w.Write([]byte("\n\n")); err != nil {
			return err
		}
	}

	return nil
}

func (b *Builder) writeToFile() error {
	outputDir := filepath.Dir(b.outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create a temporary file first to avoid partial writes
	tempFile, err := os.CreateTemp(outputDir, "temp-*.go")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	defer func() {
		tempFile.Close()
		if err != nil {
			os.Remove(tempFile.Name())
		}
	}()

	// Use the same writing logic as writeToWriter
	if err := b.writeToWriter(tempFile); err != nil {
		return err
	}

	// Close the temp file before renaming
	if err := tempFile.Close(); err != nil {
		return fmt.Errorf("failed to close temporary file: %w", err)
	}

	// Atomically replace the target file
	if err := os.Rename(tempFile.Name(), b.outputFilePath); err != nil {
		return fmt.Errorf("failed to rename temporary file: %w", err)
	}

	// According to formatCode option, decide whether to run goimports
	if b.formatCode {
		if err := util.RunGoImports(b.outputFilePath); err != nil {
			return fmt.Errorf("failed to format generated code with goimports: %w", err)
		}
	}

	return nil
}

func (b *Builder) buildImportDeclaration(importSpecs map[string]*ast.ImportSpec) ast.Decl {
	// First, collect and sort the import paths to ensure deterministic order
	importPaths := make([]string, 0, len(importSpecs))
	for path := range importSpecs {
		importPaths = append(importPaths, path)
	}
	sort.Strings(importPaths)

	// Then collect the import specs in the sorted order
	finalImportSpecs := make([]ast.Spec, 0, len(importSpecs))
	for _, path := range importPaths {
		if spec, exists := importSpecs[path]; exists {
			finalImportSpecs = append(finalImportSpecs, spec)
		}
	}

	// Sort the imports by path to maintain consistent ordering
	sort.Slice(finalImportSpecs, func(i, j int) bool {
		var iPath, jPath string
		if imp, ok := finalImportSpecs[i].(*ast.ImportSpec); ok && imp.Path != nil {
			iPath = imp.Path.Value
		}
		if imp, ok := finalImportSpecs[j].(*ast.ImportSpec); ok && imp.Path != nil {
			jPath = imp.Path.Value
		}
		return iPath < jPath
	})

	return &ast.GenDecl{Tok: token.IMPORT, Specs: finalImportSpecs}
}

// pendingSymbol holds information about a symbol that needs to be generated.
// It's used to create a deterministic processing order for name generation.
type pendingSymbol struct {
	originalName       string
	originalImportPath string
	// A pointer to the original identifier in the AST.
	// This provides a unique identity for each symbol.
	ident *ast.Ident
}

// collectAndResolveNames is the core of the deterministic name generation.
// It collects all symbols, sorts them, and resolves any naming conflicts.
func (b *Builder) collectAndResolveNames(allPackageDecls map[string]*packageDecls, definedTypes map[string]bool) map[*ast.Ident]string {
	var symbols []pendingSymbol

	// Pass 1, Step A: Collect all symbols from all packages.
	for importPath, pkgDecls := range allPackageDecls {
		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							symbols = append(symbols, pendingSymbol{originalName: name.Name, originalImportPath: importPath, ident: name})
						}
					}
				}
			}
		}
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							symbols = append(symbols, pendingSymbol{originalName: name.Name, originalImportPath: importPath, ident: name})
						}
					}
				}
			}
		}
		for _, spec := range pkgDecls.typeSpecs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				symbols = append(symbols, pendingSymbol{originalName: typeSpec.Name.Name, originalImportPath: importPath, ident: typeSpec.Name})
			}
		}
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				symbols = append(symbols, pendingSymbol{originalName: funcDecl.Name.Name, originalImportPath: importPath, ident: funcDecl.Name})
			}
		}
	}

	// Pass 1, Step B: Sort symbols for deterministic processing (by name, then by import path).
	sort.Slice(symbols, func(i, j int) bool {
		if symbols[i].originalName != symbols[j].originalName {
			return symbols[i].originalName < symbols[j].originalName
		}
		return symbols[i].originalImportPath < symbols[j].originalImportPath
	})

	// Pass 1, Step C: Generate unique names using the grouping strategy.
	nameMap := make(map[*ast.Ident]string)
	usedNames := make(map[string]bool)

	slog.Info("--- Debugging Name Generation ---")

	// Group symbols by their original name.
	groupedSymbols := make(map[string][]*pendingSymbol)
	for i := range symbols {
		s := &symbols[i]
		groupedSymbols[s.originalName] = append(groupedSymbols[s.originalName], s)
	}

	// To ensure deterministic processing of groups, get and sort the group keys.
	var sortedOriginalNames []string
	for name := range groupedSymbols {
		sortedOriginalNames = append(sortedOriginalNames, name)
	}
	sort.Strings(sortedOriginalNames)

	// Process each group to assign final, unique names.
	for _, originalName := range sortedOriginalNames {
		group := groupedSymbols[originalName]

		// The symbols within the group are already sorted by import path.
		for i, symbol := range group {
			var finalName string
			// The first symbol in a group (i=0) tries to get the clean, unsuffixed name.
			// Subsequent symbols (i>0) get a numeric suffix.
			if i == 0 {
				finalName = originalName
			} else {
				finalName = originalName + strconv.Itoa(i)
			}

			// Check if the proposed finalName conflicts with any name already in `usedNames`.
			// This `usedNames` now correctly contains only names from `definedTypes` and names assigned from *other* groups.
			if usedNames[finalName] {
				// Conflict detected with a name from `definedTypes` or a previously processed *different* group.
				// We need to find a new unique name for the current symbol.
				startSuffix := 1
				if i > 0 {
					// If this is not the first symbol in its group, and its proposed name (with suffix i) is taken,
					// then we continue searching from i+1.
					startSuffix = i + 1
				}

				for k := startSuffix; ; k++ {
					newName := originalName + strconv.Itoa(k)
					if !usedNames[newName] {
						slog.Info("Conflict resolved", "original_name", originalName, "proposed_name", finalName, "new_name", newName, "import_path", symbol.originalImportPath)
						finalName = newName
						break
					}
				}
			}

			usedNames[finalName] = true
			nameMap[symbol.ident] = finalName
		}
	}
	slog.Info("--- End Debugging Name Generation ---")

	return nameMap
}
