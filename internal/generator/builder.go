package generator

import (
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"log/slog"
	"os"
	"path/filepath"
	"sort"

	"github.com/origadmin/adptool/internal/util"
)

// GeneratedHeader is the standard header comment added to generated files.
const GeneratedHeader = "// Code generated by \"adptool\"; DO NOT EDIT.\n\n"

// Builder is responsible for building the output file from collected declarations.
type Builder struct {
	fset           *token.FileSet
	outputFilePath string
	aliasFile      *ast.File
	formatCode     bool // Controls whether to automatically format the code
	noEditHeader   bool // Controls whether to add "do not edit" header comment
	usedNames      map[string]bool
}

// NewBuilder creates a new Builder.
func NewBuilder(packageName string, outputFilePath string, noEditHeader bool) *Builder {
	return &Builder{
		fset:           token.NewFileSet(),
		outputFilePath: outputFilePath,
		aliasFile: &ast.File{
			Name:  ast.NewIdent(packageName),
			Decls: []ast.Decl{},
		},
		formatCode:   true, // Enable code formatting by default
		noEditHeader: noEditHeader,
		usedNames:    make(map[string]bool),
	}
}

// WithFormatCode sets whether to automatically format after generating code
func (b *Builder) WithFormatCode(format bool) *Builder {
	b.formatCode = format
	return b
}

// Build builds the output file structure from the collected data.
func (b *Builder) Build(importSpecs map[string]*ast.ImportSpec, allPackageDecls map[string]*packageDecls, definedTypes map[string]bool) {
	var orderedDecls []ast.Decl

	importDecl := b.buildImportDeclaration(importSpecs)
	if len(importDecl.(*ast.GenDecl).Specs) > 0 {
		orderedDecls = append(orderedDecls, importDecl)
	}

	allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls := b.collectAllDeclarations(allPackageDecls, definedTypes)

	if len(allConstSpecs) > 0 {
		constDecl := &ast.GenDecl{
			Tok:    token.CONST,
			Lparen: token.Pos(1),
			Specs:  allConstSpecs,
		}
		orderedDecls = append(orderedDecls, constDecl)
	}

	if len(allVarSpecs) > 0 {
		varDecl := &ast.GenDecl{
			Tok:    token.VAR,
			Lparen: token.Pos(1),
			Specs:  allVarSpecs,
		}
		orderedDecls = append(orderedDecls, varDecl)
	}

	if len(allTypeSpecs) > 0 {
		typeDecl := &ast.GenDecl{
			Tok:    token.TYPE,
			Lparen: token.Pos(1),
			Specs:  allTypeSpecs,
		}
		orderedDecls = append(orderedDecls, typeDecl)
	}

	orderedDecls = append(orderedDecls, allFuncDecls...)

	b.aliasFile.Decls = orderedDecls
}

// Write writes the generated code to the output file.
func (b *Builder) Write() error {
	outputDir := filepath.Dir(b.outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// If no package name is set, try to determine it from the directory
	if b.aliasFile.Name == nil || b.aliasFile.Name.Name == "" {
		// Look for Go files in the directory to determine the package name
		files, err := filepath.Glob(filepath.Join(outputDir, "*.go"))
		if err != nil {
			return fmt.Errorf("failed to list Go files in directory: %w", err)
		}

		// If no Go files exist, use the directory name as the package name
		if len(files) == 0 {
			dirName := filepath.Base(outputDir)
			// Ensure the directory name is a valid Go identifier
			if dirName != "" {
				// If the directory name starts with a number, prefix it with "pkg"
				if len(dirName) > 0 && dirName[0] >= '0' && dirName[0] <= '9' {
					dirName = "pkg" + dirName
				}
				// Remove any remaining invalid characters
				var validName []rune
				for i, r := range dirName {
					if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || r == '_' || (i > 0 && r >= '0' && r <= '9') {
						validName = append(validName, r)
					}
				}
				if len(validName) > 0 {
					b.aliasFile.Name = ast.NewIdent(string(validName))
				} else {
					// Fallback to a default package name if no valid characters found
					b.aliasFile.Name = ast.NewIdent("generated")
				}
			}
		}
	}

	// Create a temporary file first to avoid partial writes
	tempFile, err := os.CreateTemp(outputDir, "temp-*.go")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	defer func() {
		tempFile.Close()
		if err != nil {
			os.Remove(tempFile.Name())
		}
	}()

	slog.Info("Writing file with package name", "func", "Builder.Write", "package", b.aliasFile.Name.Name)

	// Add header comment if enabled
	if !b.noEditHeader {
		if _, err := tempFile.WriteString(GeneratedHeader); err != nil {
			return fmt.Errorf("failed to write header comment: %w", err)
		}
	}

	// Write the generated code
	if err := printer.Fprint(tempFile, b.fset, b.aliasFile); err != nil {
		return fmt.Errorf("failed to write generated code: %w", err)
	}

	// Close the temp file before renaming
	if err := tempFile.Close(); err != nil {
		return fmt.Errorf("failed to close temporary file: %w", err)
	}

	// Atomically replace the target file
	if err := os.Rename(tempFile.Name(), b.outputFilePath); err != nil {
		return fmt.Errorf("failed to rename temporary file: %w", err)
	}

	// According to formatCode option, decide whether to run goimports
	if b.formatCode {
		if err := util.RunGoImports(b.outputFilePath); err != nil {
			return fmt.Errorf("failed to format generated code with goimports: %w", err)
		}
	}

	return nil
}

func (b *Builder) buildImportDeclaration(importSpecs map[string]*ast.ImportSpec) ast.Decl {
	var finalImportSpecs []ast.Spec
	for _, spec := range importSpecs {
		finalImportSpecs = append(finalImportSpecs, spec)
	}

	sort.Slice(finalImportSpecs, func(i, j int) bool {
		var iPath, jPath string
		if imp, ok := finalImportSpecs[i].(*ast.ImportSpec); ok && imp.Path != nil {
			iPath = imp.Path.Value
		}
		if imp, ok := finalImportSpecs[j].(*ast.ImportSpec); ok && imp.Path != nil {
			jPath = imp.Path.Value
		}
		return iPath < jPath
	})

	return &ast.GenDecl{Tok: token.IMPORT, Specs: finalImportSpecs}
}

func (b *Builder) collectAllDeclarations(allPackageDecls map[string]*packageDecls, definedTypes map[string]bool) ([]ast.Spec, []ast.Spec, []ast.Spec, []ast.Decl) {
	slog.Debug("Current definedTypes", "func", "Builder.collectAllDeclarations", "definedTypes", definedTypes)

	var allConstSpecs []ast.Spec
	var allVarSpecs []ast.Spec
	var allTypeSpecs []ast.Spec
	var allFuncDecls []ast.Decl

	var sortedPackageAliases []string
	for alias := range allPackageDecls {
		sortedPackageAliases = append(sortedPackageAliases, alias)
	}
	sort.Strings(sortedPackageAliases)

	// Create a map to track name conflicts and assign suffixes
	nameCounters := make(map[string]int)

	// Helper function to generate a unique name with suffix
	generateUniqueName := func(name string) string {
		if count, exists := nameCounters[name]; exists {
			// Increment the counter and append it to the name
			count++
			nameCounters[name] = count
			return fmt.Sprintf("%s%d", name, count)
		}
		// First time seeing this name
		nameCounters[name] = 0
		return name
	}

	// Helper function to update the name in a ValueSpec
	updateValueSpecName := func(spec *ast.ValueSpec, newName string) *ast.ValueSpec {
		// Create a copy of the spec with the new name
		newSpec := &ast.ValueSpec{
			Doc:     spec.Doc,
			Names:   make([]*ast.Ident, len(spec.Names)),
			Type:    spec.Type,
			Values:  spec.Values,
			Comment: spec.Comment,
		}
		// Copy names but update the first one
		for i, name := range spec.Names {
			newSpec.Names[i] = &ast.Ident{
				NamePos: name.NamePos,
				Name:    newName,
				Obj:     name.Obj,
			}
		}
		return newSpec
	}

	// Helper function to update the name in a TypeSpec
	updateTypeSpecName := func(spec *ast.TypeSpec, newName string) *ast.TypeSpec {
		// Create a copy of the spec with the new name
		newSpec := &ast.TypeSpec{
			Doc:     spec.Doc,
			Name:    &ast.Ident{Name: newName},
			Assign:  spec.Assign,
			Type:    spec.Type,
			Comment: spec.Comment,
		}
		return newSpec
	}

	// Helper function to update the name in a FuncDecl
	updateFuncDeclName := func(decl *ast.FuncDecl, newName string) *ast.FuncDecl {
		// Create a copy of the decl with the new name
		newDecl := &ast.FuncDecl{
			Doc:  decl.Doc,
			Recv: decl.Recv,
			Name: &ast.Ident{Name: newName},
			Type: decl.Type,
			Body: decl.Body,
		}
		return newDecl
	}

	for _, alias := range sortedPackageAliases {
		pkgDecls := allPackageDecls[alias]

		// Extract specs from const declarations
		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, ident := range valueSpec.Names {
							uniqueName := generateUniqueName(ident.Name)
							if uniqueName != ident.Name {
								// Name was changed, create a new spec with the updated name
								newSpec := updateValueSpecName(valueSpec, uniqueName)
								allConstSpecs = append(allConstSpecs, newSpec)
								b.usedNames[uniqueName] = true
							} else if !b.usedNames[ident.Name] {
								// Name is unique, use the original spec
								allConstSpecs = append(allConstSpecs, spec)
								b.usedNames[ident.Name] = true
							}
						}
					}
				}
			}
		}

		// Extract specs from var declarations
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, ident := range valueSpec.Names {
							uniqueName := generateUniqueName(ident.Name)
							if uniqueName != ident.Name {
								// Name was changed, create a new spec with the updated name
								newSpec := updateValueSpecName(valueSpec, uniqueName)
								allVarSpecs = append(allVarSpecs, newSpec)
								b.usedNames[uniqueName] = true
							} else if !b.usedNames[ident.Name] {
								// Name is unique, use the original spec
								allVarSpecs = append(allVarSpecs, spec)
								b.usedNames[ident.Name] = true
							}
						}
					}
				}
			}
		}

		// Handle Types
		for _, spec := range pkgDecls.typeSpecs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				uniqueName := generateUniqueName(typeSpec.Name.Name)
				if uniqueName != typeSpec.Name.Name {
					// Name was changed, create a new spec with the updated name
					newSpec := updateTypeSpecName(typeSpec, uniqueName)
					allTypeSpecs = append(allTypeSpecs, newSpec)
					b.usedNames[uniqueName] = true
				} else if !b.usedNames[typeSpec.Name.Name] {
					// Name is unique, use the original spec
					allTypeSpecs = append(allTypeSpecs, spec)
					b.usedNames[typeSpec.Name.Name] = true
				}
			}
		}

		// Handle Funcs
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				uniqueName := generateUniqueName(funcDecl.Name.Name)
				if uniqueName != funcDecl.Name.Name {
					// Name was changed, create a new decl with the updated name
					newDecl := updateFuncDeclName(funcDecl, uniqueName)
					allFuncDecls = append(allFuncDecls, newDecl)
					b.usedNames[uniqueName] = true
				} else if !b.usedNames[funcDecl.Name.Name] {
					// Name is unique, use the original decl
					allFuncDecls = append(allFuncDecls, decl)
					b.usedNames[funcDecl.Name.Name] = true
				}
			}
		}
	}

	return allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls
}
