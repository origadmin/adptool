package generator

import (
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"log/slog"
	"os"
	"path/filepath"
	"sort"

	"github.com/origadmin/adptool/internal/util"
)

// GeneratedHeader is the standard header comment added to generated files.
const GeneratedHeader = "// Code generated by \"adptool\"; DO NOT EDIT.\n\n"

// Builder is responsible for building the output file from collected declarations.
type Builder struct {
	fset           *token.FileSet
	outputFilePath string
	aliasFile      *ast.File
	formatCode     bool // 控制是否自动格式化代码
	noEditHeader   bool // 控制是否添加"do not edit"头部注释
	usedNames      map[string]bool
}

// NewBuilder creates a new Builder.
func NewBuilder(packageName string, outputFilePath string, noEditHeader bool) *Builder {
	return &Builder{
		fset:           token.NewFileSet(),
		outputFilePath: outputFilePath,
		aliasFile: &ast.File{
			Name:  ast.NewIdent(packageName),
			Decls: []ast.Decl{},
		},
		formatCode:   true, // 默认启用代码格式化
		noEditHeader: noEditHeader,
		usedNames:    make(map[string]bool),
	}
}

// WithFormatCode 设置是否在生成代码后自动格式化
func (b *Builder) WithFormatCode(format bool) *Builder {
	b.formatCode = format
	return b
}

// Build builds the output file structure from the collected data.
func (b *Builder) Build(importSpecs map[string]*ast.ImportSpec, allPackageDecls map[string]*packageDecls, definedTypes map[string]bool) {
	var orderedDecls []ast.Decl

	importDecl := b.buildImportDeclaration(importSpecs)
	if len(importDecl.(*ast.GenDecl).Specs) > 0 {
		orderedDecls = append(orderedDecls, importDecl)
	}

	allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls := b.collectAllDeclarations(allPackageDecls, definedTypes)

	if len(allConstSpecs) > 0 {
		constDecl := &ast.GenDecl{
			Tok:    token.CONST,
			Lparen: token.Pos(1),
			Specs:  allConstSpecs,
		}
		orderedDecls = append(orderedDecls, constDecl)
	}

	if len(allVarSpecs) > 0 {
		varDecl := &ast.GenDecl{
			Tok:    token.VAR,
			Lparen: token.Pos(1),
			Specs:  allVarSpecs,
		}
		orderedDecls = append(orderedDecls, varDecl)
	}

	if len(allTypeSpecs) > 0 {
		typeDecl := &ast.GenDecl{
			Tok:    token.TYPE,
			Lparen: token.Pos(1),
			Specs:  allTypeSpecs,
		}
		orderedDecls = append(orderedDecls, typeDecl)
	}

	orderedDecls = append(orderedDecls, allFuncDecls...)

	b.aliasFile.Decls = orderedDecls
}

// Write writes the generated code to the output file.
func (b *Builder) Write() error {
	outputDir := filepath.Dir(b.outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create a temporary file first to avoid partial writes
	tempFile, err := os.CreateTemp(outputDir, "temp-*.go")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	defer func() {
		tempFile.Close()
		if err != nil {
			os.Remove(tempFile.Name())
		}
	}()

	slog.Info("Writing file with package name", "func", "Builder.Write", "package", b.aliasFile.Name.Name)

	// Add header comment if enabled
	if !b.noEditHeader {
		if _, err := tempFile.WriteString(GeneratedHeader); err != nil {
			return fmt.Errorf("failed to write header comment: %w", err)
		}
	}

	// Write the generated code
	if err := printer.Fprint(tempFile, b.fset, b.aliasFile); err != nil {
		return fmt.Errorf("failed to write generated code: %w", err)
	}

	// Close the temp file before renaming
	if err := tempFile.Close(); err != nil {
		return fmt.Errorf("failed to close temporary file: %w", err)
	}

	// Atomically replace the target file
	if err := os.Rename(tempFile.Name(), b.outputFilePath); err != nil {
		return fmt.Errorf("failed to rename temporary file: %w", err)
	}

	// 根据formatCode选项决定是否运行goimports
	if b.formatCode {
		if err := util.RunGoImports(b.outputFilePath); err != nil {
			return fmt.Errorf("failed to format generated code with goimports: %w", err)
		}
	}

	return nil
}

func (b *Builder) buildImportDeclaration(importSpecs map[string]*ast.ImportSpec) ast.Decl {
	var finalImportSpecs []ast.Spec
	for _, spec := range importSpecs {
		finalImportSpecs = append(finalImportSpecs, spec)
	}

	sort.Slice(finalImportSpecs, func(i, j int) bool {
		var iPath, jPath string
		if imp, ok := finalImportSpecs[i].(*ast.ImportSpec); ok && imp.Path != nil {
			iPath = imp.Path.Value
		}
		if imp, ok := finalImportSpecs[j].(*ast.ImportSpec); ok && imp.Path != nil {
			jPath = imp.Path.Value
		}
		return iPath < jPath
	})

	return &ast.GenDecl{Tok: token.IMPORT, Specs: finalImportSpecs}
}

func (b *Builder) collectAllDeclarations(allPackageDecls map[string]*packageDecls, definedTypes map[string]bool) ([]ast.Spec, []ast.Spec, []ast.Spec, []ast.Decl) {
	slog.Debug("Current definedTypes", "func", "Builder.collectAllDeclarations", "definedTypes", definedTypes)

	var allConstSpecs []ast.Spec
	var allVarSpecs []ast.Spec
	var allTypeSpecs []ast.Spec
	var allFuncDecls []ast.Decl

	var sortedPackageAliases []string
	for alias := range allPackageDecls {
		sortedPackageAliases = append(sortedPackageAliases, alias)
	}
	sort.Strings(sortedPackageAliases)

	for _, alias := range sortedPackageAliases {
		pkgDecls := allPackageDecls[alias]

		// Extract specs from const declarations
		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, ident := range valueSpec.Names {
							if !b.usedNames[ident.Name] {
								allConstSpecs = append(allConstSpecs, spec)
								b.usedNames[ident.Name] = true
							}
						}
					}
				}
			}
		}

		// Extract specs from var declarations
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, ident := range valueSpec.Names {
							if !b.usedNames[ident.Name] {
								allVarSpecs = append(allVarSpecs, spec)
								b.usedNames[ident.Name] = true
							}
						}
					}
				}
			}
		}

		// Handle Types
		for _, spec := range pkgDecls.typeSpecs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				if !b.usedNames[typeSpec.Name.Name] {
					allTypeSpecs = append(allTypeSpecs, spec)
					b.usedNames[typeSpec.Name.Name] = true
				}
			}
		}

		// Handle Funcs
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				if !b.usedNames[funcDecl.Name.Name] {
					allFuncDecls = append(allFuncDecls, decl)
					b.usedNames[funcDecl.Name.Name] = true
				}
			}
		}
	}

	return allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls
}
