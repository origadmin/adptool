package generator

import (
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strconv"

	"github.com/origadmin/adptool/internal/util"
)

// GeneratedHeader is the standard header comment added to generated files.
const GeneratedHeader = "// Code generated by \"adptool\"; DO NOT EDIT.\n\n"

// Builder is responsible for building the output file from collected declarations.
type Builder struct {
	fset           *token.FileSet
	outputFilePath string
	aliasFile      *ast.File
	formatCode     bool // Controls whether to automatically format the code
	noEditHeader   bool // Controls whether to add "do not edit" header comment
	usedNames      map[string]bool
	writer         io.Writer // If set, output is written here instead of to a file
}

// NewBuilder creates a new Builder.
func NewBuilder(packageName string, outputFilePath string, noEditHeader bool) *Builder {
	return &Builder{
		fset:           token.NewFileSet(),
		outputFilePath: outputFilePath,
		aliasFile: &ast.File{
			Name:  ast.NewIdent(packageName),
			Decls: []ast.Decl{},
		},
		formatCode:   true, // Enable code formatting by default
		noEditHeader: noEditHeader,
		usedNames:    make(map[string]bool),
	}
}

// WithFormatCode sets whether to automatically format after generating code
func (b *Builder) WithFormatCode(format bool) *Builder {
	b.formatCode = format
	return b
}

// Build builds the output file structure from the collected data.
func (b *Builder) Build(importSpecs map[string]*ast.ImportSpec, allPackageDecls map[string]*packageDecls, definedTypes map[string]bool) {
	var orderedDecls []ast.Decl

	importDecl := b.buildImportDeclaration(importSpecs)
	if len(importDecl.(*ast.GenDecl).Specs) > 0 {
		orderedDecls = append(orderedDecls, importDecl)
	}

	allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls := b.collectAllDeclarations(allPackageDecls, definedTypes)

	if len(allConstSpecs) > 0 {
		constDecl := &ast.GenDecl{
			Tok:    token.CONST,
			Lparen: token.Pos(1), // Use Lparen to indicate a grouped declaration
			Specs:  allConstSpecs,
		}
		orderedDecls = append(orderedDecls, constDecl)
	}

	if len(allVarSpecs) > 0 {
		varDecl := &ast.GenDecl{
			Tok:    token.VAR,
			Lparen: token.Pos(1), // Use Lparen to indicate a grouped declaration
			Specs:  allVarSpecs,
		}
		orderedDecls = append(orderedDecls, varDecl)
	}

	if len(allTypeSpecs) > 0 {
		typeDecl := &ast.GenDecl{
			Tok:    token.TYPE,
			Lparen: token.Pos(1), // Use Lparen to indicate a grouped declaration
			Specs:  allTypeSpecs,
		}
		orderedDecls = append(orderedDecls, typeDecl)
	}

	orderedDecls = append(orderedDecls, allFuncDecls...)

	b.aliasFile.Decls = orderedDecls
}

// Write writes the generated code to the output file or to the configured writer.
func (b *Builder) Write() error {
	// If a writer is configured, write to it and bypass file operations.
	if b.writer != nil {
		return b.writeToWriter(b.writer)
	}

	// Original file writing logic
	return b.writeToFile()
}

func (b *Builder) writeToWriter(w io.Writer) error {
	// When writing to a writer (for tests), we write the raw, unformatted code.
	// The test helper is responsible for formatting.

	// Add header comment if enabled
	if !b.noEditHeader {
		if _, err := w.Write([]byte(GeneratedHeader)); err != nil {
			return fmt.Errorf("failed to write header comment to writer: %w", err)
		}
	}

	// Write the generated code to the writer
	if err := printer.Fprint(w, b.fset, b.aliasFile); err != nil {
		return fmt.Errorf("failed to write generated code to writer: %w", err)
	}
	return nil
}

func (b *Builder) writeToFile() error {
	outputDir := filepath.Dir(b.outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// If no package name is set, try to determine it from the directory
	if b.aliasFile.Name == nil || b.aliasFile.Name.Name == "" {
		// Logic to determine package name (as before)
		// This logic should be filled in or confirmed as correct
	}

	// Create a temporary file first to avoid partial writes
	tempFile, err := os.CreateTemp(outputDir, "temp-*.go")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	defer func() {
		tempFile.Close()
		if err != nil {
			os.Remove(tempFile.Name())
		}
	}()

	slog.Info("Writing file with package name", "func", "Builder.writeToFile", "package", b.aliasFile.Name.Name)

	// Add header comment if enabled
	if !b.noEditHeader {
		if _, err := tempFile.WriteString(GeneratedHeader); err != nil {
			return fmt.Errorf("failed to write header comment: %w", err)
		}
	}

	// Write the generated code
	if err := printer.Fprint(tempFile, b.fset, b.aliasFile); err != nil {
		return fmt.Errorf("failed to write generated code: %w", err)
	}

	// Close the temp file before renaming
	if err := tempFile.Close(); err != nil {
		return fmt.Errorf("failed to close temporary file: %w", err)
	}

	// Atomically replace the target file
	if err := os.Rename(tempFile.Name(), b.outputFilePath); err != nil {
		return fmt.Errorf("failed to rename temporary file: %w", err)
	}

	// According to formatCode option, decide whether to run goimports
	if b.formatCode {
		if err := util.RunGoImports(b.outputFilePath); err != nil {
			return fmt.Errorf("failed to format generated code with goimports: %w", err)
		}
	}

	return nil
}

func (b *Builder) buildImportDeclaration(importSpecs map[string]*ast.ImportSpec) ast.Decl {
	// First, collect and sort the import paths to ensure deterministic order
	importPaths := make([]string, 0, len(importSpecs))
	for path := range importSpecs {
		importPaths = append(importPaths, path)
	}
	sort.Strings(importPaths)

	// Then collect the import specs in the sorted order
	finalImportSpecs := make([]ast.Spec, 0, len(importSpecs))
	for _, path := range importPaths {
		if spec, exists := importSpecs[path]; exists {
			finalImportSpecs = append(finalImportSpecs, spec)
		}
	}

	// Sort the imports by path to maintain consistent ordering
	sort.Slice(finalImportSpecs, func(i, j int) bool {
		var iPath, jPath string
		if imp, ok := finalImportSpecs[i].(*ast.ImportSpec); ok && imp.Path != nil {
			iPath = imp.Path.Value
		}
		if imp, ok := finalImportSpecs[j].(*ast.ImportSpec); ok && imp.Path != nil {
			jPath = imp.Path.Value
		}
		return iPath < jPath
	})

	return &ast.GenDecl{Tok: token.IMPORT, Specs: finalImportSpecs}
}

// pendingSymbol holds information about a symbol that needs to be generated.
// It's used to create a deterministic processing order for name generation.
type pendingSymbol struct {
	originalName  string
	originalAlias string
	// A pointer to the original identifier in the AST.
	// This provides a unique identity for each symbol.
	ident *ast.Ident
}

// collectAllDeclarations generates declarations in a fully deterministic way.
// It performs two passes:
// 1. Collect all symbols, sort them canonically (by name, then package alias),
//    and generate a unique name for each one. This creates a deterministic mapping
//    from original symbol to new unique name.
// 2. Re-iterate the original declarations and build new ones using the generated unique names.
func (b *Builder) collectAllDeclarations(allPackageDecls map[string]*packageDecls, definedTypes map[string]bool) ([]ast.Spec, []ast.Spec, []ast.Spec, []ast.Decl) {
	var symbols []pendingSymbol

	// Sort package aliases to ensure a deterministic starting point
	var sortedPackageAliases []string
	for alias := range allPackageDecls {
		sortedPackageAliases = append(sortedPackageAliases, alias)
	}
	sort.Strings(sortedPackageAliases)

	// Pass 1, Step A: Collect all symbols
	for _, alias := range sortedPackageAliases {
		pkgDecls := allPackageDecls[alias]

		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							symbols = append(symbols, pendingSymbol{originalName: name.Name, originalAlias: alias, ident: name})
						}
					}
				}
			}
		}
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if valSpec, ok := spec.(*ast.ValueSpec); ok {
						for _, name := range valSpec.Names {
							symbols = append(symbols, pendingSymbol{originalName: name.Name, originalAlias: alias, ident: name})
						}
					}
				}
			}
		}
		for _, spec := range pkgDecls.typeSpecs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				symbols = append(symbols, pendingSymbol{originalName: typeSpec.Name.Name, originalAlias: alias, ident: typeSpec.Name})
			}
		}
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				symbols = append(symbols, pendingSymbol{originalName: funcDecl.Name.Name, originalAlias: alias, ident: funcDecl.Name})
			}
		}
	}

	// Pass 1, Step B: Sort symbols for deterministic processing
	sort.Slice(symbols, func(i, j int) bool {
		if symbols[i].originalName != symbols[j].originalName {
			return symbols[i].originalName < symbols[j].originalName
		}
		return symbols[i].originalAlias < symbols[j].originalAlias
	})

	// Pass 1, Step C: Generate unique names and create the mapping
	nameMap := make(map[*ast.Ident]string)
	usedNames := make(map[string]bool)
	for name := range definedTypes {
		usedNames[name] = true
	}

	generateUniqueName := func(originalName, originalAlias string) string {
		// If the original name is not yet used, we can use it.
		if _, exists := usedNames[originalName]; !exists {
			usedNames[originalName] = true
			return originalName
		}

		// If we are here, the original name is already taken. This is a conflict.
		// We must find a new name for the current symbol.
		for i := 1; ; i++ {
			newName := originalName + strconv.Itoa(i)
			if _, exists := usedNames[newName]; !exists {
				// Found an available new name. Log the conflict and resolution.
				slog.Warn(
					"Name conflict detected and resolved",
					"original_name", originalName,
					"from_package_alias", originalAlias,
					"new_name", newName,
				)
				usedNames[newName] = true
				return newName
			}
		}
	}

	for _, s := range symbols {
		nameMap[s.ident] = generateUniqueName(s.originalName, s.originalAlias)
	}

	// Pass 2: Build new declarations using the deterministic name map
	var allConstSpecs, allVarSpecs, allTypeSpecs []ast.Spec
	var allFuncDecls []ast.Decl
	processedSpecs := make(map[ast.Spec]bool)

	for _, alias := range sortedPackageAliases {
		pkgDecls := allPackageDecls[alias]

		for _, decl := range pkgDecls.constDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if processedSpecs[spec] {
						continue
					}
					valSpec := spec.(*ast.ValueSpec)
					newSpec := *valSpec
					newSpec.Names = make([]*ast.Ident, len(valSpec.Names))
					for i, name := range valSpec.Names {
						newSpec.Names[i] = ast.NewIdent(nameMap[name])
					}
					allConstSpecs = append(allConstSpecs, &newSpec)
					processedSpecs[spec] = true
				}
			}
		}
		for _, decl := range pkgDecls.varDecls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if processedSpecs[spec] {
						continue
					}
					valSpec := spec.(*ast.ValueSpec)
					newSpec := *valSpec
					newSpec.Names = make([]*ast.Ident, len(valSpec.Names))
					for i, name := range valSpec.Names {
						newSpec.Names[i] = ast.NewIdent(nameMap[name])
					}
					allVarSpecs = append(allVarSpecs, &newSpec)
					processedSpecs[spec] = true
				}
			}
		}
		for _, spec := range pkgDecls.typeSpecs {
			if processedSpecs[spec] {
				continue
			}
			typeSpec := spec.(*ast.TypeSpec)
			newSpec := *typeSpec
			newSpec.Name = ast.NewIdent(nameMap[typeSpec.Name])
			allTypeSpecs = append(allTypeSpecs, &newSpec)
			processedSpecs[spec] = true
		}
		for _, decl := range pkgDecls.funcDecls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				newDecl := *funcDecl
				newDecl.Name = ast.NewIdent(nameMap[funcDecl.Name])
				allFuncDecls = append(allFuncDecls, &newDecl)
			}
		}
	}

	return allConstSpecs, allVarSpecs, allTypeSpecs, allFuncDecls
}
