package generator

import (
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"regexp"

	"github.com/origadmin/adptool/internal/config"
	adptoolparser "github.com/origadmin/adptool/internal/parser"
)

// Generate is the main function for the code generation process.
func Generate(cfg *config.Config, filePaths []string, outputPath string) error {
	fset := token.NewFileSet()

	for _, path := range filePaths {
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("failed to parse file %s: %w", path, err)
		}

		// The parser will update the cfg object based on directives
		_, err = adptoolparser.ParseFileDirectives(cfg, node, fset)
		if err != nil {
			return fmt.Errorf("failed to parse directives in file %s: %w", path, err)
		}
	}

	// 2. Build the AdapterSpec from the updated config.
	spec, err := buildAdapterSpec(cfg)
	if err != nil {
		return fmt.Errorf("failed to build adapter spec: %w", err)
	}

	// 3. Render the Go code using a template.
	// (Template logic will be added in the next step)
	generatedCode := []byte(fmt.Sprintf("// Code generated by adptool. DO NOT EDIT.\n\npackage %s\n", spec.PackageName))

	// 4. Write the generated code to the output file.
	return os.WriteFile(outputPath, generatedCode, 0644)
}

// buildAdapterSpec constructs the final specification for the template.
func buildAdapterSpec(cfg *config.Config) (*AdapterSpec, error) {
	spec := &AdapterSpec{
		PackageName: "adapters", // Default, can be overridden
		Imports:     make(map[string]string),
	}

	// Process global rules
	processRules(cfg.Types, "type", spec)
	processRules(cfg.Functions, "func", spec)
	processRules(cfg.Variables, "var", spec)
	processRules(cfg.Constants, "const", spec)

	// Process package-specific rules
	for _, pkg := range cfg.Packages {
		if pkg.Import != "" {
			spec.Imports[pkg.Import] = pkg.Alias
		}
		processRules(pkg.Types, "type", spec)
		processRules(pkg.Functions, "func", spec)
		processRules(pkg.Variables, "var", spec)
		processRules(pkg.Constants, "const", spec)
	}

	return spec, nil
}

// Helper function to process different rule types
func processRules[T interface {
	GetName() string
	GetRuleSet() *config.RuleSet
}](rules []T, itemType string, spec *AdapterSpec) {
	for _, rule := range rules {
		if rule.GetRuleSet().Disabled {
			continue
		}
		adaptedItem := AdaptedItem{
			OriginalName: rule.GetName(),
			ItemType:     itemType,
			Rules:        convertRuleSetToRenameRules(rule.GetRuleSet()),
		}
		spec.AdaptedItems = append(spec.AdaptedItems, adaptedItem)
	}
}

// convertRuleSetToRenameRules converts a config.RuleSet to a slice of RenameRule.
func convertRuleSetToRenameRules(rs *config.RuleSet) []RenameRule {
	var renameRules []RenameRule

	if rs.Prefix != "" {
		renameRules = append(renameRules, RenameRule{Type: "prefix", Value: rs.Prefix})
	}
	if rs.Suffix != "" {
		renameRules = append(renameRules, RenameRule{Type: "suffix", Value: rs.Suffix})
	}
	for _, explicit := range rs.Explicit {
		renameRules = append(renameRules, RenameRule{Type: "explicit", From: explicit.From, To: explicit.To})
	}
	for _, regex := range rs.Regex {
		renameRules = append(renameRules, RenameRule{Type: "regex", Pattern: regex.Pattern, Replace: regex.Replace})
	}
	// Add other rule types as needed

	return renameRules
}

// applyRules applies a set of rename rules to a given name and returns the result.
func applyRules(name string, rules []RenameRule) (string, error) {
	currentName := name
	for _, rule := range rules {
		switch rule.Type {
		case "explicit":
			if name == rule.From {
				return rule.To, nil // Explicit rule is final
			}
		case "prefix":
			currentName = rule.Value + currentName
		case "suffix":
			currentName = currentName + rule.Value
		case "regex":
			re, err := regexp.Compile(rule.Pattern)
			if err != nil {
				return "", fmt.Errorf("invalid regex pattern '%s': %w", rule.Pattern, err)
			}
			currentName = re.ReplaceAllString(currentName, rule.Replace)
		}
	}
	return currentName, nil
}
