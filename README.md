# adptool

[![CI](https://github.com/origadmin/adptool/actions/workflows/ci.yml/badge.svg)](https://github.com/origadmin/adptool/actions/workflows/ci.yml)
[![Release](https://img.shields.io/github/v/release/origadmin/adptool)](https://github.com/origadmin/adptool/releases/latest)
[![Go Report Card](https://goreportcard.com/badge/github.com/origadmin/adptool)](https://goreportcard.com/report/github.com/origadmin/adptool)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

`adptool` is a powerful and highly configurable Go code generator that automates the creation of adapter code. It helps you seamlessly integrate third-party libraries and internal modules by generating type aliases, function wrappers, and method proxies based on a clear and powerful configuration system.

## Why use adptool?

-   **Unify APIs**: Create a consistent, internal-facing API for diverse external libraries.
-   **Decouple Dependencies**: Isolate your core logic from specific third-party implementations.
-   **Enforce Naming Conventions**: Apply systematic naming rules (prefixes, suffixes, etc.) across your codebase.
-   **Eliminate Boilerplate**: Automate the generation of repetitive adapter code.
-   **Improve Maintainability**: Adapt to upstream changes by modifying configuration, not manual code.

## Installation

#### From Source
```bash
go install github.com/origadmin/adptool/cmd/adptool@latest
```

#### Pre-compiled Binaries
Visit the [**Releases Page**](https://github.com/origadmin/adptool/releases) to download a pre-compiled binary for your platform.

---

## Quick Start

Let's see a simple example. Imagine you're using a library with a generic `Client` and you want to adapt it to your project's naming conventions.

**1. Add a directive to your Go file:**

Create a file, e.g., `adapters/adapters.go`, to mark what you want to adapt.

```go
// adapters/adapters.go
package adapters

//go:adapter:package github.com/some-org/some-lib
```

**2. Create a configuration file:**

In your project root, create an `.adptool.yaml` file to define the renaming rules.

```yaml
# .adptool.yaml
types:
  prefix: "My"
  explicit:
    - from: "Client"
      to: "MyLibClient"

functions:
  prefix: "New"
```

**3. Run adptool:**

```bash
adptool .
```

**4. Get the generated code:**

`adptool` will generate a file like `adapters/generate.adapter.go` with the adapted code:

```go
// Code generated by "adptool"; DO NOT EDIT.

package adapters

import (
	somelib "github.com/some-org/some-lib"
)

// Types
type MyLibClient = somelib.Client // Renamed from "Client" via explicit rule
type MyConfig = somelib.Config     // Renamed via "My" prefix rule

// Functions
var (
	NewClient = somelib.NewClient // Renamed via "New" prefix rule
)
```
This simple example shows how `adptool` can automate the creation of consistent, project-specific adapters.

---

## Detailed Usage

### 1. Define Directives in Go Source

First, place simple `//go:adapter` directives in your Go files. These directives mark the packages, types, functions,
and methods you intend to adapt. They act as markers for `adptool` to target.

**Example: `directives.go`**

```go
// directives.go
package my_adapters

// --- Directives ---
// Mark the entire package for adaptation. Rules are defined in .adptool.yaml
//go:adapter:package github.com/some-org/some-lib
```

### 2. Define Rules in `.adptool.yaml`

This is where the power of `adptool` lies. Create a `.adptool.yaml` file in your project root to define all adaptation
rules. The configuration is hierarchical and maps directly to Go's syntax.

#### Configuration Hierarchy

Rules are applied from the most general to the most specific. A more specific rule set is merged with its parent to
produce a final value.

1. **Top-Level Rules**: These are the global rules that apply to everything.
2. **Package-Level Rules**: Defined inside a `packages` entry, these rules are merged with the top-level rules.

#### Declaration Structure

The configuration structure mirrors Go's syntax. Rules can be defined at the top level (for global rules) or within a
`packages` entry.

- `types`: Rules for `type T ...` declarations.
    - `methods`: Nested rules for the type's methods, `func (t T) M() ...`.
    - `fields`: Nested rules for a `struct`'s fields.
- `functions`: Rules for top-level functions, `func F() ...`.
- `variables`: Rules for `var V ...`.
- `constants`: Rules for `const C ...`.

#### Rule Priority (Within a Single Declaration)

After all rules for a declaration have been merged and calculated, they are applied to a name in this order:

1. **`ignore`**: If the name is in the final `ignore` list, it is skipped.
2. **`explicit`**: If the name is in the final `explicit` map, it is renamed, and **no other rules apply**.
3. **`prefix` & `suffix`**: If not found in `explicit`, the final `prefix` and `suffix` are applied.
4. **`regex`**: The final `regex` rules are applied to the result of the previous step.

### Example: `.adptool.yaml`

```yaml
# .adptool.yaml

# 1. Define global default behaviors
defaults:
  mode:
    prefix: "append"   # Default for all prefixes
    explicit: "merge"  # Default for all explicit maps

# 2. Define top-level (global) rules
functions:
  prefix: "Call_"

types:
  prefix: "T_"
  explicit:
    - from: "Reader"
      to: "SourceReader"
  methods:
    # This inherits its prefix mode ('append') from defaults.mode.prefix
    # It merges with the parent rule from 'functions', resulting in "Call_Method_"
    prefix: "Method_"

# 3. Define package-specific rules that override/merge with global rules
packages:
  - import: "github.com/some-org/some-lib"
    # This package has its own 'types' rules
    types:
      # This prefix merges with the global "T_" prefix, resulting in "T_Lib_"
      prefix: "Lib_"
      methods:
        # This mode overrides the global default. It will not merge.
        prefix_mode: "replace"
        # The final prefix for methods in this package is just "Safe"
        prefix: "Safe"

```

### 3. Run the Tool

Execute `adptool` from your project root. It will find your directives and configuration, and generate the adapter code.

```sh
# Generate code, scanning all .go files in the current directory.
adptool .

# Specify an output file.
adptool -o ./my_adapters.go .

# Use a specific config file instead of the default .adptool.yaml
adptool -c ./configs/custom.yaml .
```

## Contributing

Contributions are welcome! Please feel free to submit an Issue or Pull Request.

## License

`adptool` is released under the [MIT License](LICENSE).
